## 클래스

객체 : 물리적으로 존재하거나 추상적으로 생각할 수 있는 것

자신의 속성을 가지고 있고, 다른것과 식별 가능한 것.



객체지향 프로그래밍 : 부품에 해당하는 객체를 먼저 만들고, 이것들을 하나씩 조립해서 완성된 프로그램을 만드는 기법

만들고자 하는 객체(완성품)를 모델링 하고, 집합 관계에 있는 부품 객체와 사용 관계에 있는 객체를 하나씩 설계한 후 조립하는 방법으로 프로그램을 개발하는 기법



객체는 속성과 동작으로 구성

속성 <=> 필드

동작 <=> 메소드



객체 모델링 : 현실세계의 객체를 소프트웨어 객체로 설계하는것



객체 간의 관계 : 집합, 사용, 상속 관계

- 집합 관계 : 집합 관계에 있는 객체는 하나는 부품이고 하나는 완성품, has-a 관계
- 사용 관계 : 객체 간의 상호작용을 말함
- 상속 관계 : 상위 객체를 기반으로 하위 객체를 생성하는 관계 is-a 관계

객체의 상호작용 : 객체들 사이의 데이터를 주고받는 수단은 메소드





객체지향 프로그래밍의 특징

1. 캡슐화

   - 실제 구현 내용을 감추는 것
   - 외부 객체는 객체내부의 구조를 알지 못하며, 객체가 노출해서 제공하는 필드와 메소드만 이용
   - 필드와 메소드를 캡슐화하여 보호하는 이유 : 외부의 잘못된 사용으로 인해 객체가 손상되지 않게 하기 위함
   - 노출시킬 것인지 숨길 것인지 => 접근 제한자 사용

2. 상속

   - 프로그램에서는 자식이 부모를 선택할 수 있다.

   - public class A extends B() 와 같이 클래스 선언 뒤에 extends 키워드를 붙인 후 상속받을 클래스를 기술해준다.

   - 자바는 다중 상속을 허용하지 않는다.

   - 상위 객체를 재사용해서 하위 객체를 쉽고 빨리 설계(코드의 중복을 줄여줌)

   - 상위 객체의 수정으로 모든 하위 객체들이 수정 효과를 가져옴(유지 보수 시간 최소화)

   - 자식 객체를 생성하면 부모 객체가 먼저 생성되고 자식 객체가 그 다음에 생성된다.

   - 부모 객체를 생성하기 위해 부모 생성자를 super 키워드로 호출할 수 있다.

     - 명시적으로 부모 생성자를 호출하는 경우 만약 매개값의 타입과 일치하는 부모 생성자가 없다면 컴파일 오류가 발생

   - 메소드 오버라이딩

     - 상속된 메소드의 내용이 자식 클래스와 맞지 않을 경우 자식 클래스에서 동일한 메소드를 재정의 하는 것을 말함
     - 메소드 오버라이딩 시 부모 객체의 메소드는 숨겨지기 때문에 자식 객체에서 메소드 호출 시 오버라이딩 된 메소드가 호출됨
     - 만약 자식 클래스에서 오버라이딩 된 부모 클래스의 메소드를 호출해야 하는 경우 super.부모메소드();로 호출할 수 있다.
     - 부모의 메소드와 동일한 리턴 타입, 메소드 이름, 매개 변수 리스트를 가져야 한다.
     - 접근 제한을 더 강하게 오버라이딩 할 수 없다.
     - 새로운 예외를 만들 수 없다.

   - final

     - final 키워드는 클래스, 필드, 메소드 선언 시에 사용할 수 있다.
     - 필드 : 초기값 설정 후, 더 이상 값을 변경할 수 없다.
     - 클래스 : 부모 클래스가 될 수 없어(상속할 수 없어)자식 클래스를 만들 수 없다.
     - 메소드 : 오버라이딩 할 수 없는 메소드

   - 접근 제한자

     - | 접근 제한 |          적용 대상           |             접근할 수 없는 클래스              |
       | :-------: | :--------------------------: | :--------------------------------------------: |
       |  public   | 클래스, 필드, 생성자, 메소드 |                      없음                      |
       | protected |     필드, 생성자, 메소드     | 자식 클래스가 아닌 다른 패키지에 소속된 클래스 |
       |  default  | 클래스, 필드, 생성자, 메소드 |          다른 패키지에 소속된 클래스           |
       |  private  |     필드, 생성자, 메소드     |                모든 외부 클래스                |

   - 자동 타입 변환

     - 부모클래스 변수 = 자식클래스타입;
     - 부모 타입으로 자동 타입변환된 이후 접근 가능한 멤버는 부모 클래스 멤버로만 한정된다.
     - 만약 오버라이딩 된 메소드라면 자식 클래스의 메소드가 대신 호출된다.
     - 바로 위의 부모가 아니더라도 상속 계층에서 상위 타입이라면 자동 타입 변환이 일어날 수 있다.

   - 강제 타입 변환

     - 자식클래스 변수 = (자식클래스) 부모킬래스 타입;
     - 강제 타입 변환은 부모 타입을 자식 타입으로 변환 하는 것을 말한다.(물론 다 되는건 아님)
     - 자식 타입이 부모 타입으로 자동 변환된 후, 다시 자식 타입으로 변환할 때 강제 타입 변환을 사용할 수 있다.

   - 객체 타입 확인

     - 어떤 객체가 어떤 클래스의 인스턴스인지 확인하려면 instanseof 연산자를 사용할 수 있다.
     - boolean res = 좌항(객체) instanceof 우항(타입)

3. 다형성

   - 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질
   - 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해줌
   - 다형성을 위해 자바는 부모 클래스로 타입 변환과 인텁=페이스의 타입 변환을 허용함
     - 부모 클래스에 모든 자식 객체가 대입될 수 있음
     - 인터페이스 타입에는 모든 구현 객체가 대입될 수 있음
   - 다형성의 효과로 객체는 부품화가 가능함

   - 매개 변수의 다형성
     - 매개 변수의 타입이 클래스일 경우, 해당 클래스의 객체뿐만 아니라 자식 객체까지도 매개값으로 사용할 수 있다.

현실에서 객체는 갑자기 하늘에서 떨어지는 것이 아니라 설계도를 바탕으로 만들어진다.

자바에서는 설계도가 바로 클래스이다.



클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고 한다.

클래스로부터 객체를 만드는 과정을 인스턴스화라고 한다.



클래스 선언

사용하고자 하는 객체를 구상했다면, 그 객체의 대표 이름을 하나 결정하고 이것을 클래스 이름으로 함

클래스 이름 작성 규칙

1. 하나 이상의 문자로 구성되어야 한다
2. 첫번째 글자는 숫자가 올 수 없다
3. $, _ 외에 특수 문자는 사용할 수 없다
4. 자바 키워드는 사용할 수 없다

클래스 이름을 정했다면 "클래스이름.java"로 소스 파일을 생성

소스 파일당 하나의 클래스를 선언하지만, 두개 이상의 클래스 선언도 가능하다

소스 파일은 클래스 선언을 담고 있는 저장 단위일 뿐, 클래스 자체가 아니다

두 개 이상의 클래스가 선언된 소스 파일을 컴파일하면 바이트 코드 파일(.class)은 클래스를 선언한 개수만큼 생긴다

주의할 점 : 파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한자를 붙일 수 있다



객체 생성과 클래스 변수

- 객체를 생성하는 방법 => new 연산자를 사용
- new는 클래스로부터 객체를 생성시키는 연산자
- new 연산자로 생성된 객체는 메모리 힙 영역에 생성된다
- [현실세계]물건의 위치 <==> [객체지향 프로그램] 객체의 위치
  - new 연산자는 힙 영역에 객체를 생성시킨 후 객체의 주소를 리턴

클래스의 용도

1. 라이브러리용
2. 실행용

- 라이브러리 클래스는 다른 클래스에서 이용할 목적으로 설계된다.
- 실행 클래스는 main 메소드를 제공하는 역할을 한다.
- 프로그램 전체에서 사용되는 클래스가 100개라면 그중 99개가 라이브러리용이고 단 하나가 실행 클래스이다.
- 라이브러리인 동시에 실행 클래스도 만들 수 있다.
- 하지만 대부분의 객체지향 프로그램은 라이브러리와 실행 클래스가 분리되어 있다.

클래스의 구성 멤버

- 필드 : 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳
  - 초기값이 지정되지 않은 필드들은 객체 생성 시 자동으로 기본 초기값으로 설정된다.
  - 필드 사용
    - 클래스 내부: 단순히 필드 이름으로 읽고 변경
    - 클래스 외부 : 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용
- 생성자 : new 연산자로 호출되는 특별한 중괄호 블록
  - 클래스 이름으로 되어 있고 리턴 타입이 없다.
  - new 연산자와 같이 객체를 생성할 때 호출되어 객체의 초기화를 담당한다
  - 생성자 선언을 생략했다면 컴파일러는 기본 생성자를 바이트 코드에 자동으로 추가시킨다.
  - 관례적으로 매개변수는 필드와 동일한 이름을 갖도록 함
  - 매개 변수 선언 : 생성자를 호출할 때 외부의 값을 생성자 블록 내부로 전달하는 역할
  - 생성자에서 다른 생성자를 호출할 때 this() 코드를 사용한다.
  - 생성자 오버로딩
    - 매개 변수를 달리하는 생성자를 여러 개 선언(매개변수의 타입, 개수, 순서가 다르게 선언)
- 메소드 : 필드를 읽고 수정하는 역할, 객체간의 데이터 전달의 수단으로 사용
  - 리턴값이 있느냐 없느냐에 따라 메소드를 호출하는 방법이 조금씩 다르다.(리턴값이 있다면 변수에 값을 넣어주기)
  - 그러나 리턴 타입이 있다고 해서 반드시 변수에 저장할 필요는 없다.
  - 클래스 내부에서 호출 시 단순한 메소드 이름으로 호출
  - 외부에서 호출 시 클래스로 객체를 생성 후, 참조 변수를 통해 메소드 호출
  - 메소드 작성 규칙
    - 숫자로 시작하지 말것
    - $와 _를 제외한 특수문자를 사용하지 말것
    - 카멜 케이스로 작성한다
  - 매개 변수의 수를 모를 경우
    - 배열 타입으로 선언 : int sum(int[] a), 배열의 항목 수는 호출할 때 결정된다
    - 배열 타입으로 선언 시 메소드를 호출하기 전에 배열을 생성해야 하는 불편한 점이 있다.(리스트만 넘겨주는 방법이 있음)
    - 메소드의 매개 변수를 "..."를 사용해서 선언하면 리스트를 넘겨줄 수 있다.
  - 리턴문
    - 리턴값이 있는 메소드
      - return 문의 리턴값은 리턴 타입이거나 리턴 타입으로 변환 될 수 있어야 한다.(byte와 short는 자동 int 타입 변환)
      - return 문 이후에 실행문이 오면 컴파일 오류 발생(조건문으로 분기처리 해주기)
    - 리턴값이 없는 메소드
      - void로 선언된 리턴값이 없는 메소드에서도 return문을 사용할 수 있다.
  - 메소드 오버로딩
    - 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것
      - 매개값을 다양하게 받아 처리할 수 있도록 하기 위해서
    - 매개변수의 타입, 개수, 순서 중 하나가 달라야 한다.
    - 오버로딩된 메소드를 호출할경우 JVM은 매개값의 타입을 보고 메소드를 선택한다.
      - 만약 일치하지 않을 경우 자동 타입 변환이 가능한지 검사한다.

인스턴스

- 인스턴스 멤버 : 객체를 생성한 후 사용할수 있는 필드와 메소드
- 인스턴스 필드와 메소드는 객체 없이는 사용할 수 없다.
- 인스턴스 필드는 객체마다 따로 존재하고, 인스턴스 메소드는 메소드 영역에 저장되고 공유된다.
- 객체 외부에서 접근 시 참조 변수를 사용하고, 내부에서 접근 시 this를 사용한다.
- this는 주로 생성자나 메소드의 매개 변수 이름이 필드와 동일한 경우 인스턴스 멤버임을 명시하고자 할 때 사용된다.

정적 멤버와 스테틱

- 정적 멤버 : 클래스에 고정된 멤버
- 정적 멤버는 객체에 소속된 멤버가 아니라 클래스에 소속된 멤버이기 때문에 클래스 멤버라고도 부른다.
- 필드 선언 시
  - 인스턴스 필드로 선언할 것인가, 정적 필드로 선언할 것이가 판단기준
    - 객체마다 가지고 있어야 할 데이터라면 인스턴스 필드
    - 그게 아니고 공용적인 데이터라면 정적 필드
- 메소드 선언 시
  - 인스턴스 메소드로 선언할 것인가, 정적 메소드로 선언할 것인가 판단기준
    - 인스턴스 필드를 이용해서 실행해야 하면 인스턴스 메소드
    - 인스턴스 필드를 이용하지 않는다면 정적 메소드
- 정적 멤버 사용
  - 클래스 이름과 함께 도트 연산자로 접근
- 정적 멤버는 원칙적으로는 클래스 이름으로 접근해야 하지만 객체 참조 변수로도 접근이 가능
- 하지만 정적 멤버는 클래스 이름으로 접근하는 것이 좋다.
- 정적 초기화 블록
  - 정적 필드는 필드 선언과 동시에 초기값을 주는게 보통이다.
- 인스턴스 필드는 생성자에서 초기화하지만 자바는 정적 필드의 초기화 작업을 위해 정적 블록을 제공한다.
- 정적 메소드와 정적 블록을 선언할 때 주의점
  - 블록 내부에 인스턴스 멤버, this 키워드 사용 불가능
  - 블록 내부에 인스턴스 멤버를 사용하고 싶다면 객체를 먼저 생성하고 참조 변수로 접근해야 한다.

상수

- 불변의 값을 저장하는 필드
- Final 과 상수는 다름
- 상수는 객체마다 저장할 필요가 없는 공용성을 띄고 있으며 여러 가지 값으로 초기화할 수 없기 때문
- 상수는 스테틱이면서 final이여야 한다.

패키지

- 자바에서는 클래스를 체계적으로 관리하기 위해 패키지를 사용한다.
- 클래스의 전체 이름은 "패키지명 + 클래스명"이다.
- 패키지가 중요한 이유는 클래스만 따로 복사해서 다른 곳으로 이동하면 클래스는 사용할 수 없기 때문.
- 패키지 이름 규칙
  - 숫자로 시작하지 말것
  - $, _를 제외한 특수 문자를 사용하지 말것
  - java로 시작하는 패키지는 자바 표준 api에서만 사용하므로 사용하지 말것
  - 모두 소문자로 작성하는것이 국룰
  - 보통 여러 회사에서는 패키지 이름이 중복되지 않게 도메인 이름 역순을 사용한다.

Import 문

- 다른 패키지의 속하는 클래스를 사용하기 위함 

1. 패키지와 클래스를 모두 기술
2. import문 사용

게터세터 메소드

- 객체의 무결성이 깨지지 않도록 메소드를 통해 데이터를 변경하는 방법을 말함
